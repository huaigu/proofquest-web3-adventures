# Primus zkTLS Solidity Integration Guide

This document provides comprehensive guidance for developers creating smart contracts that integrate with Primus zkTLS technology for zero-knowledge proof verification and confidential computing.

## Overview

Primus zkTLS protocol provides smart contracts deployed across multiple blockchains to verify data proofs generated by users via the zkTLS SDK. The system enables verifiable confidential computing through FHE (Fully Homomorphic Encryption) and zero-knowledge proofs.

## Supported Networks

- **Ethereum Mainnet** (`ethereum`)
- **Ethereum Holesky Testnet** (`holesky`) 
- **AO Network** (`ao`)

## Core Smart Contract Interfaces

### 1. IDataPermission Interface

This is the primary interface for implementing custom data permission checking logic:

```solidity
interface IDataPermission {
    /**
     * @notice Check whether data user can buy the data
     * @param dataUser The data user to buy the data.
     * @param dataId The data id.
     * @return Return true if the data user can buy the data, else false.
     */
    function isPermitted(address dataUser, bytes32 dataId) external returns (bool);
}
```

**Implementation Details:**
- Data providers can assign a `checker contract address` for data permission checking while uploading data
- When a task is submitted by a data user, the Primus Network Contract requests permission from the assigned contract
- The contract decides whether to continue or terminate the task based on the results returned

**Example Implementation:**
- Reference: [WhiteListDataPermission](https://github.com/pado-labs/pado-network-sdk/blob/main/demo/contracts/WhiteListDataPermission.sol)

### 2. Price Information Structure

```typescript
interface PriceInfo {
    price: string;
    symbol: string;
}
```

**Price Calculation:**
- If symbol is 'wAR' (AO network): price of 1 = 0.000000000001 wAR
- If symbol is 'ETH' (Ethereum networks): price of 1 = 1 wei

## Contract Architecture

### Core Contract Modules

Primus Contracts consist of multiple modules:

1. **Worker Management Contract**
   - Handles worker registration
   - Stores worker information: name, description, public key, owner address, machine resources, RPC details

2. **Data Management Contract** 
   - Manages data information registration
   - Handles encrypted data uploaded to Arweave storage

3. **Task Management Contract**
   - Handles computation task submission with user public keys
   - Manages task verification and result reporting
   - Distributes fees to data providers and workers

4. **Fee Management Module**
   - Handles payment processing for computation and data usage fees
   - Manages token transfers through smart contracts

## Official Contract Repositories

- **Ethereum Contracts**: [Primus Network Contracts](https://github.com/pado-labs/pado-network-contracts)
- **AO Contracts**: [Primus AO Process](https://github.com/pado-labs/pado-ao-process)
- **Main Interface**: [IDataPermission.sol](https://github.com/pado-labs/pado-network-contracts/blob/main/contracts/interface/IDataPermission.sol)

## Integration Patterns

### 1. Data Marketplace Integration

```solidity
// Example pattern for marketplace integration
contract DataMarketplace {
    function purchaseData(bytes32 dataId) external payable {
        // Complete token transfer through smart contract
        // Access encrypted data after payment verification
    }
}
```

### 2. Worker Registration

Workers must register with the worker management module providing:
- Name and description
- Owner address
- Machine resources specification
- RPC address and port
- Worker's public key

### 3. Permission Checking Integration

```solidity
contract CustomPermissionChecker is IDataPermission {
    mapping(address => mapping(bytes32 => bool)) public permissions;
    
    function isPermitted(address dataUser, bytes32 dataId) 
        external 
        override 
        returns (bool) 
    {
        // Implement custom permission logic
        return permissions[dataUser][dataId];
    }
    
    function grantPermission(address dataUser, bytes32 dataId) 
        external 
        onlyOwner 
    {
        permissions[dataUser][dataId] = true;
    }
}
```

## Advanced Use Cases

### 1. Confidential Voting Systems

Integration with ERC20/ERC721 token contracts for DAO voting:
- Token contracts serve as prerequisites for governor contracts
- Governor contracts manage proposals and voting
- zkFHE ensures vote confidentiality while maintaining integrity

### 2. Blind Auction Contracts

```solidity
contract BlindAuction {
    // Communicate with zkFHE network for shared public key creation
    // Handle encrypted bid submissions
    // Manage collateral/deposits in smart contract
    // Reveal winning bid through threshold decryption
}
```

### 3. Confidential Transaction Systems

```solidity
contract ConfidentialTransactions {
    // Handle balance re-encryption from network public key to user public key
    // Require user signature authentication for balance viewing
    // Manage wrapped asset minting/burning for withdrawals
}
```

### 4. Dark Pool Implementation

```solidity
contract DarkPool {
    // Enhanced trustless trading through smart contracts
    // Decentralized protocols with privacy protection
    // Integration with zkFHE for transaction confidentiality
}
```

## Development Best Practices

### 1. Permission Contract Design

- Implement robust access control mechanisms
- Consider gas optimization for permission checking
- Design flexible permission models (whitelist, role-based, etc.)

### 2. Data ID Management

- Use `bytes32` for data identifiers
- Implement proper data lifecycle management
- Handle data expiration and cleanup

### 3. Fee Management

- Implement secure payment processing
- Handle fee distribution to multiple parties
- Consider gas costs in fee calculations

### 4. Error Handling

```solidity
contract PrimusIntegration {
    error DataAccessDenied(address user, bytes32 dataId);
    error InsufficientPayment(uint256 required, uint256 provided);
    error WorkerNotRegistered(address worker);
    
    modifier onlyPermittedUser(bytes32 dataId) {
        if (!permissionChecker.isPermitted(msg.sender, dataId)) {
            revert DataAccessDenied(msg.sender, dataId);
        }
        _;
    }
}
```

## Security Considerations

### 1. Authentication and Authorization

- Always verify user signatures for sensitive operations
- Implement proper access controls for data and worker management
- Use time-based restrictions where appropriate

### 2. Data Privacy

- Ensure encrypted data remains confidential throughout processing
- Implement proper key management for FHE operations
- Verify zero-knowledge proofs before accepting results

### 3. Economic Security

- Implement collateral/staking mechanisms for workers
- Design incentive-compatible fee structures
- Handle payment failures and refunds properly

## Example Integration Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./IDataPermission.sol";

contract PrimusDataVerifier {
    struct VerificationRequest {
        bytes32 dataId;
        address requester;
        uint256 fee;
        bool verified;
    }
    
    mapping(bytes32 => VerificationRequest) public requests;
    IDataPermission public permissionChecker;
    
    event DataVerified(bytes32 indexed dataId, address indexed requester);
    
    constructor(address _permissionChecker) {
        permissionChecker = IDataPermission(_permissionChecker);
    }
    
    function requestVerification(bytes32 dataId) 
        external 
        payable 
    {
        require(msg.value > 0, "Fee required");
        require(
            permissionChecker.isPermitted(msg.sender, dataId),
            "Access denied"
        );
        
        requests[dataId] = VerificationRequest({
            dataId: dataId,
            requester: msg.sender,
            fee: msg.value,
            verified: false
        });
    }
    
    function verifyData(bytes32 dataId, bytes calldata proof) 
        external 
    {
        // Implement proof verification logic
        // Mark as verified after successful verification
        requests[dataId].verified = true;
        emit DataVerified(dataId, requests[dataId].requester);
    }
}
```

## Next Steps

1. Review the official contract repositories for complete implementations
2. Test integrations on supported testnets (Holesky recommended)
3. Implement custom permission logic based on your use case requirements
4. Consider gas optimization and user experience in your contract design
5. Follow security best practices for handling sensitive data and payments

This guide provides the foundation for building smart contracts that integrate with Primus zkTLS technology. For specific implementation details and updates, refer to the official repositories and documentation.